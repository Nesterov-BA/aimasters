\documentclass{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
% \usepackage[left=1cm,right=1cm,top=1cm,bottom=1cm]{geometry}
\usepackage{hyperref}
\usepackage{seqsplit}
\usepackage[dvipsnames]{xcolor}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\usepackage{mathalfa}
\usepackage{mathrsfs}
\usepackage{dsfont}
\usepackage{caption,subcaption}
\usepackage{wrapfig}
\usepackage[stable]{footmisc}
\usepackage{indentfirst}
\usepackage{rotating}
\usepackage{pdflscape}

\usepackage{minted}

\usepackage{MnSymbol,wasysym}

\begin{document}

\begin{center}
  \Large {Задание 3. Сортировки}
\end{center}

\textbf{1} Заметим, что если у $i$-го подошедшего клиента время облуживания
$t_{i}$, то суммарное время ожидания будет
\[T = \sum\limits_{i = 1}^{n}(n-i+1)t_{i}\]
Далее рассмотрим $t_{i}, t_{j}: i<j, t_{i} \geq t_{j}$. Если мы
поменяем этих клиентов местами, $T$
уменьшится на $(j-i)t_{i}$ и увеличится на $(j-i)t_{j}$, в результате
$T$ уменьшится на $(j-i)(t_{i} - t_{j}) \ge 0$, т. е.
$T$ не увеличится. Получаем, что расстановка с наименьшим суммарным
временем ожидания --- это
расстановка при которой время ожидания каждого следующего клиента не убывает.
Алгоритм тем самым должен просто отсортировать клиентов по убыванию
времени ожидания. Для
этого подойдет сортировка слиянием, работающая за $O(n\log n)$, что
является наилучшим вариантом с
точки зрения асимптотики.

\medskip

\textbf{2} Вначале выделим память под два массива: $m$ длиной $k-1$,
$ord$ длиной $n$. Эти операции в общей сложности $\Theta(n)$.
Затем, пройдем один раз по исходному массиву и на $i$-е место в массиве $m$
запишем, сколько котов имеют массу не более $i+2$(нумерация массивов
с $0$). Это также займет $\Theta(n)$.
Далее, пройдем исходный массив заново, совершая следующте действия:
\\
Допустим, что кот с кличкой $i$ имеет массу $j$. Также допустим, что
до этого мы встретили
$p$ котов той же массы. Тогда мы сделаем запись $ord\bigl[m[j-3] +
p\bigr] = i$(если $j = 2, ord[p] = i$).
Получается, что мы разбили массив индексов на последовательные
ячейки, каждая из которых
содержит клички котов определенной массы, при этом эти ячейки стоят
по возрастанию
массы. Последняя операция также линейна по $n$. В итоге, алгоритм
работает за \textbf{$\Theta(n)$}.
\medskip

\textbf{3} Установим три указателя на начало каждого из массивов и
увеличим число уникальных элементов на
нужное значение (если 3 уникальных то на три, если 2 на 2 и если все
равны то на 1), в отдельных
переменных будем хранить последнее число, записанное из каждого из
массивов. Далее шаг следующий: после сдвига
сначала оставляем только уникальные элементы на указателях, затем
сравниваем каждое из чисел с соответствующим
значением в переменной, и увеличиваем количество если не совпали.
Если доходим до конца массива,
соответствующий указатель останавливается.
Итого, мы проходим каждый массив один раз. На каждом шаге делается
число сравнений, не зависящих от длин массивов.
Полученный алгоритм работает за $O(n)$.

\medskip

\textbf{5} Сперва заметим, что порядок, в котором стоят элементы
массива только меняет местами слагаемые в сумме, то есть
сама сумма от него не зависит. Поэтому далее считаем массив
отсортированным по возрастанию.
Поделим весь массив на пары $(a_{k}, a_{2n - k}), k = 0, \dots, n-1$,
т. е. так чтобы первый стоял с последним, второй с
предпоследним и т. д. Далее рассмотрим конкретную пару $(a_{k},
a_{2n-k})$. Если число $s$ находится между $a_{k}$ и $a_{2n-k}$
то сумма $|s - a_{k}| + |s - a_{2n - k}|$ равна $a_{2n-k} - a_{k}$.
Если же $s$ лежит за пределами этого отрезка, сумма будет
строго больше $a_{2n-k} - a_{k}$. Отсюда получаем, что для всех пар
число $s$ должно быть
внитри образованных этими парами отрезков. Остается заметить, что
$a_{n}$ стоит в паре с самим собой, т. е.
образует отрезок из одной точки, лежащий в пересечении всех других
отрезков. Тем самым, для минимизации суммы необходимо
и достаточно, чтобы $s$ совпадало с $a_{n}$. Так как мы предполагали,
что массив отсортирован по возрастанию,
для исходного массива $s$ должно быть равно $a_{(n)}$ --- $n$-ой
порядковой статистике. Алгоритм находящий
$n$-ую порядковую статистику работает за $O(n)$.
\end{document}

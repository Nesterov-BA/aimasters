% !TEX encoding = Windows Cyrillic
\documentclass[11pt,a4paper]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
%\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{mathtext}
\usepackage{amsfonts,amssymb,amsmath,amsbsy,amsthm,amscd}
\usepackage{inputenc,ifthen}
\usepackage[pdftex]{graphicx}
\usepackage{wrapfig}
\usepackage[left=12mm,right=12mm,top=10mm,bottom=10mm]{geometry}
\pagestyle{empty}
\makeatletter
\DeclareRobustCommand{\No}{\ifmmode{\nfss@text{\textnumero}}\else\textnumero\fi}
\makeatother

\newcommand*{\hm}[1]{#1\nobreak\discretionary{}%
{\hbox{$\mathsurround=0pt #1$}}{}}

\newcommand{\ds}{\displaystyle}

\newsavebox{\kar}
\newbox\bx
\renewcommand{\le}{\leqslant}\renewcommand{\leq}{\leqslant}
\renewcommand{\ge}{\geqslant}\renewcommand{\geq}{\geqslant}

\newlength{\tasksep}
\newlength{\smalltasksep}
\setlength{\tasksep}{3 mm}
\setlength{\smalltasksep}{1 mm}

\newcounter{zadacha}

\newcommand{\tema}[1]{\hrule\vskip 3mm\par\small{{Алгоритмы} \hfill Задание 4. Сортировки, порядковые статистики.}



\vskip 3mm \hrule
\setcounter{zadacha}{0}\medskip\noindent \centerline{\bf\Large #1}\par\smallskip}

\newcommand{\forstudents}[1]{}
\newcommand{\forteachers}[1]{#1}

\newcommand{\algebra}{
\tema{ }





%\zA{Откуда}{Условие}
%{Решение}
%{Ответ}{Подсказка}{Комментарий}


\zA{}{На вход задачи поступают три отсортированных массива. Постройте алгоритм, находящий число уникальных элементов в объединении этих массивов.}
{Установим три указателя на начало каждого из массивов и увеличим число уникальных элементов на
  нужное значение (если 3 уникальных то на три, если 2 на 2 и если все равны то на 1), в отдельных
  переменных будем хранить последнее число, записанное из каждого из массивов. Далее шаг следующий: после сдвига
  сначала оставляем только уникальные элементы на указателях, затем сравниваем каждое из чисел с соответствующим
  значением в переменной, и увеличиваем количество если не совпали. Если доходим до конца массива,
  соответствующий указатель останавливается.
  Итого, мы проходим каждый массив один раз. На каждом шаге делается число сравнений, не зависящих от длин массивов.
  Полученный алгоритм работает за $O(n)$.
}
{}{}{}


\zA{}{На вход задачи поступает массив $a$ из $n$ чисел. Постройте алгоритм, находящий число инверсий в массиве, то есть таких пар индексов $i, j$, что $i < j$ и $a[i] > a[j]$.}
{
    }
{}{}{}

\zA{}{На прямой задано $n$ отрезков в виде пар концов $(l_i, r_i)$. Они могут поступать на вход в произвольном порядке. Постройте алгоритм, находящий \textbf{множество точек на прямой}, покрытое ровно $\lceil \frac{2n}{3} \rceil$ отрезками.
}
{}
{}{}{}

\zA{}{На вход поступает число $n$ и массив $a$ размера $2n + 1$. Постройте алгоритм, находящий число $s$, минимизирующее сумму $\sum\limits_{i=1}^{2n+1} |a_i - s|$}
{Сперва заметим, что порядок, в котором стоят элементы массива только меняет местами слагаемые в сумме, то есть
  сама сумма от него не зависит. Поэтому далее считаем массив отсортированным по возрастанию.
  Поделим весь массив на пары $(a_{k}, a_{2n - k}), k = 0, \dots, n-1$, т. е. так чтобы первый стоял с последним, второй с
  предпоследним и т. д. Далее рассмотрим конкретную пару $(a_{k}, a_{2n-k})$. Если число $s$ находится между $a_{k}$ и $a_{2n-k}$
  то сумма $|s - a_{k}| + |s - a_{2n - k}|$ равна $a_{2n-k} - a_{k}$. Если же $s$ лежит за пределами этого отрезка, сумма будет
  строго больше $a_{2n-k} - a_{k}$. Отсюда получаем, что для всех пар число $s$ должно быть
  внитри образованных этими парами отрезков. Остается заметить, что $a_{n}$ стоит в паре с самим собой, т. е.
  образует отрезок из одной точки, лежащий в пересечении всех других отрезков. Тем самым, для минимизации суммы необходимо
  и достаточно, чтобы $s$ совпадало с $a_{n}$. Так как мы предполагали, что массив отсортирован по возрастанию,
  для исходного массива $s$ должно быть равно $a_{(n)}$ --- $n$-ой порядковой статистике. Алгоритм находящий
  $n$-ую порядковую статистику работает за $O(n)$.
}
{}{}{}



}

\begin{document}

\setlength{\textfloatsep}{7pt plus 2pt minus 2pt}
\setlength{\abovedisplayskip}{6pt plus 1pt minus 1pt}
\setlength{\belowdisplayskip}{6pt plus 1pt minus 1pt}
\setlength{\abovedisplayshortskip}{0pt plus 2pt}
\setlength{\belowdisplayshortskip}{4pt plus 1pt minus 1pt}
\setlength{\parindent}{0pt}

\newcommand{\zA}[6]{%
\par\vspace{\tasksep}\noindent%
\addtocounter{zadacha}{1}%
{\textbf{\arabic{zadacha} (#1).}}%
{ %
	#2\par%
	\ifthenelse{\equal{#4}{}}{}{\vskip 1mm%
		\textbf{Ответ:} #4.\par}%
	\ifthenelse{\equal{#5}{}}{}{\vskip 1mm%
		\textbf{Подсказка:} #5\par}%
	{\vskip 1mm%
		$\vartriangleright$ #3~$\vartriangleleft$}%
	\ifthenelse{\equal{#6}{}}{}{\vskip 1mm%
		\par\textbf{Комментарий:} #6\par}%
}%
}

\algebra



\end{document}
